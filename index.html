        <!DOCTYPE html>
        <html>
        <head>
            <title>dYdX Liquidity Analysis</title>
            <style>
        body { background: #0f1115; color: #d7dce2; font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; }
        h1 { font-size: 22px; font-weight: 700; margin: 8px 0 16px; }
        .controls { margin-bottom: 12px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content: space-between; }
        .controls button { background: #1e222b; color: #e6edf3; border: 1px solid #2a2f3b; padding: 8px 12px; border-radius: 8px; cursor: pointer; }
        .controls input, .controls select { background: #0f1115; color: #e6edf3; border: 1px solid #2a2f3b; padding: 8px 10px; border-radius: 8px; }
        .muted { color: #8b949e; font-size: 12px; }
        .loading { margin: 12px 0; color: #8b949e; }
        .error { color: #ff6b6b; margin: 12px 0; }
        .summary { display: flex; gap: 16px; flex-wrap: wrap; margin: 8px 0 4px; }
        .summary-item { background: #10131a; border: 1px solid #2a2f3b; padding: 8px 12px; border-radius: 8px; font-size: 13px; }
        .progress-wrap { display: flex; align-items: center; gap: 10px; min-width: 280px; }
        .progress { width: 200px; height: 8px; background: #1a1f2a; border-radius: 999px; overflow: hidden; border: 1px solid #273040; }
        .progress > span { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, #2a7cff, #7d9cff); transition: width .2s ease; }
        table { width: 100%; border-collapse: collapse; background: #0f1115; }
        thead th { position: sticky; top: 0; background: #0f1115; border-bottom: 1px solid #272b35; padding: 12px 14px; font-weight: 600; color: #a6aeb9; text-align: left; cursor: pointer; user-select: none; font-size: 14px; }
        thead th:hover { background: #151921; }
        thead th.sortable::after { content: ' ⇅'; opacity: 0.3; }
        thead th.sorted-asc::after { content: ' ↑'; opacity: 1; }
        thead th.sorted-desc::after { content: ' ↓'; opacity: 1; }
        tbody td { border-bottom: 1px solid #1a1e27; padding: 12px 14px; font-size: 14px; }
        .right { text-align: right; font-variant-numeric: tabular-nums; font-size: 14px; }
        .main-row { background: #10131a; cursor: pointer; font-size: 15px; }
        .main-row:hover { background: #131824; }
        .pair { display: inline-flex; align-items: center; gap: 8px; }
        .caret { display: inline-block; width: 10px; height: 10px; border-right: 2px solid #778090; border-bottom: 2px solid #778090; transform: rotate(-45deg); transition: transform .15s ease; margin-right: 8px; }
        .expanded .caret { transform: rotate(45deg); }
        .sub-row { background: #0c0f14; display: none; }
        .sub-row td { padding: 12px 14px !important; border-bottom: 1px solid #1a1e27 !important; }
        .depth-breakdown { display: flex; gap: 16px; justify-content: flex-end; }
        .depth-item { display: flex; align-items: center; gap: 8px; }
        .depth-item-label { color: #8b949e; font-size: 12px; text-transform: uppercase; letter-spacing: .02em; }
        .depth-item-value { font-variant-numeric: tabular-nums; font-size: 14px; font-weight: 600; }
        .bid { color: #ff9b9b; }
        .ask { color: #7ee787; }
        .group-row td { background: #0b0e13; border-bottom: 1px solid #222836; color: #a6aeb9; font-weight: 600; font-size: 13px; padding-top: 16px; }
        .group-sub { color: #8b949e; font-weight: 400; font-size: 12px; margin-left: 8px; }
        .gh-repo-link { position: fixed; top: 20px; right: 20px; z-index: 1000; display: inline-flex; align-items: center; gap: 8px; color: #a6aeb9; text-decoration: none; opacity: .85; padding: 6px 10px; border: 1px solid #2a2f3b; border-radius: 8px; background: #0f1115; }
        .gh-repo-link:hover { opacity: 1; background: #151921; }
        .gh-repo-link svg { width: 18px; height: 18px; fill: currentColor; }
            </style>
        </head>
        <body>
            <a class="gh-repo-link" href="https://github.com/Pocket-Protector/pairDepth-dYdX" target="_blank" rel="noopener noreferrer" title="Open GitHub repository">
                <svg viewBox="0 0 16 16" aria-hidden="true">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.01.08-2.11 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.91.08 2.11.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.19 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8Z"></path>
                </svg>
                <span>GitHub</span>
            </a>
            <h1>dYdX Liquidity Analysis</h1>
    <div class="controls">
        <div class="left-controls" style="display:flex;gap:12px;align-items:center;">
            <button id="refreshBtn">Refresh</button>
            <label>
                Number format:
                <select id="formatSelect">
                    <option value="full" selected>Full</option>
                    <option value="compact">K / M / B</option>
                </select>
            </label>
        </div>
        <div class="progress-wrap">
            <div class="progress"><span id="pbInner"></span></div>
            <div class="muted" id="pbText">Idle</div>
        </div>
    </div>
    <div class="summary" id="summaryBar">
        <div class="summary-item" id="sumMarkets">Total markets: -</div>
    </div>
    <div class="muted" style="margin-bottom:8px;">Filters: excluding inactive (FINAL_SETTLEMENT) and low-volume markets (24h volume < $1,000).</div>
    <div class="muted" id="samplingInfo" style="margin-bottom:8px;"></div>
    <div id="loading" class="loading" style="display:none;">Loading markets and orderbooks...</div>
    <div id="error" class="error" style="display:none;"></div>
            <table>
                <thead>
                    <tr id="headerRow"></tr>
                </thead>
        <tbody id="tableBody"></tbody>
    </table>
    <script>
        const BASE_URL = 'https://indexer.dydx.trade/v4';
        const MARKETS_PATH = '/perpetualMarkets';
        const ORDERBOOK_PATH_TMPL = '/orderbooks/perpetualMarket/{market}';
        // Depth columns to display (in %), plus a full-depth column
        const DEPTH_BANDS = [
            { key: '0.08', pct: 0.08 },
            { key: '0.10', pct: 0.10 },
            { key: '0.12', pct: 0.12 },
            { key: '0.15', pct: 0.15 },
            { key: '0.20', pct: 0.20 },
            { key: '0.25', pct: 0.25 },
            { key: '0.30', pct: 0.30 },
            { key: '0.50', pct: 0.50 },
            { key: '0.75', pct: 0.75 },
            { key: '1.00', pct: 1.00 },
            { key: '5.00', pct: 5.00 },
            { key: 'full', pct: null }
        ];

        // Sampling configuration to stabilize depth estimates
        const SAMPLING = {
            enabled: true,      // toggle averaging on/off
            samples: 12,        // number of snapshots per ticker
            intervalMs: 400,    // delay between snapshots (ms)
            retrySamples: 16    // samples used during zero-depth retries
        };

        let formatMode = 'full';

        function fmtNum(x) {
            if (x === null || x === undefined || Number.isNaN(x)) return '';
            const n = Number(x);
            if (!Number.isFinite(n)) return '';
            return n.toLocaleString(undefined, { maximumFractionDigits: 6 });
        }

        function fmtUsd(n) {
            if (n === null || n === undefined || Number.isNaN(n)) return '';
            const num = Number(n);
            if (!Number.isFinite(num)) return '';
            const opts = {
                style: 'currency',
                currency: 'USD',
                maximumFractionDigits: formatMode === 'compact' ? 2 : 2,
                notation: formatMode === 'compact' ? 'compact' : 'standard',
                compactDisplay: 'short'
            };
            return new Intl.NumberFormat(undefined, opts).format(num);
        }

        // Precise USD formatting for prices (no compact, up to 6 decimals). Display-only; calculations use raw numbers.
        function fmtUsdMid(n) {
            if (n === null || n === undefined || Number.isNaN(n)) return '';
            const num = Number(n);
            if (!Number.isFinite(num)) return '';
            const opts = {
                style: 'currency',
                currency: 'USD',
                maximumFractionDigits: 6,
                notation: 'standard'
            };
            return new Intl.NumberFormat(undefined, opts).format(num);
        }

        function makeDepthTooltip(pair, mid, pct, bandTotals) {
            if (!Number.isFinite(mid)) return '';
            const lower = mid * (1 - pct / 100);
            const upper = mid * (1 + pct / 100);
            const parts = [];
            parts.push(`${pair} ${pct}% price band`);
            parts.push(`Mid: ${fmtUsdMid(mid)}`);
            parts.push(`Range: ${fmtUsdMid(lower)} – ${fmtUsdMid(upper)}`);
            if (bandTotals && bandTotals[pct]) {
                const bid = Number(bandTotals[pct].bid);
                const ask = Number(bandTotals[pct].ask);
                if (Number.isFinite(bid) || Number.isFinite(ask)) {
                    parts.push(`Notional within band → bids: ${fmtUsd(bid || 0)}, asks: ${fmtUsd(ask || 0)}`);
                }
            }
            return parts.join('\n');
        }

        function joinUrl(base, path) {
            return (base.endsWith('/') ? base.slice(0, -1) : base) + (path.startsWith('/') ? path : '/' + path);
        }

        function renderSamplingInfo() {
            const el = document.getElementById('samplingInfo');
            if (!el) return;
            if (SAMPLING.enabled) {
                el.textContent = `Depth smoothing: averaging ${SAMPLING.samples} snapshots per market, ${SAMPLING.intervalMs}ms apart (retries use ${SAMPLING.retrySamples}).`;
            } else {
                el.textContent = `Depth smoothing: off (single snapshot per market).`;
            }
        }

        function columnCount() {
            return 4 + DEPTH_BANDS.length; // Ticker, 24h Vol, OI, Mid + depth columns
        }

        function buildTableHeader() {
            const headerRow = document.getElementById('headerRow');
            if (!headerRow) return;
            const cells = [];
            cells.push('<th class="sortable" data-column="ticker">Ticker</th>');
            cells.push('<th class="sortable right" data-column="volume24h">24h Volume</th>');
            cells.push('<th class="sortable right" data-column="oiUsd">Open Interest (USD)</th>');
            cells.push('<th class="sortable right" data-column="mid">Mid Price</th>');
            for (const spec of DEPTH_BANDS) {
                if (spec.pct === null) {
                    cells.push('<th class="sortable right" data-column="depth-full">Full Depth</th>');
                } else {
                    cells.push(`<th class="sortable right" data-column="depth-${spec.key}">${spec.key}% Depth</th>`);
                }
            }
            headerRow.innerHTML = cells.join('');
        }

        async function fetchJson(url) {
            const res = await fetch(url, { method: 'GET' });
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
            return await res.json();
        }

        function computeMid(bids, asks) {
            if (!bids.length || !asks.length) return NaN;
            const bestBid = bids.reduce((m, r) => Math.max(m, Number(r.price)), -Infinity);
            const bestAsk = asks.reduce((m, r) => Math.min(m, Number(r.price)), Infinity);
            return (bestBid + bestAsk) / 2;
        }

        function accumulateDepth(bids, asks, mid, pct) {
            const lower = mid * (1 - pct);
            const upper = mid * (1 + pct);
            let bidNotional = 0;
            let askNotional = 0;

            for (const b of bids) {
                const price = Number(b.price);
                const size = Number(b.size);
                if (Number.isFinite(price) && Number.isFinite(size) && price >= lower) {
                    bidNotional += price * size;
                }
            }

            for (const a of asks) {
                const price = Number(a.price);
                const size = Number(a.size);
                if (Number.isFinite(price) && Number.isFinite(size) && price <= upper) {
                    askNotional += price * size;
                }
            }

            return { bidNotional, askNotional, total: bidNotional + askNotional };
        }

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        function computeBandTotals(bids, asks, mid) {
            const totals = {};
            const bandTotals = {};
            for (const spec of DEPTH_BANDS) {
                if (spec.pct === null) {
                    let bidNotional = 0;
                    let askNotional = 0;
                    for (const b of bids) {
                        const price = Number(b.price);
                        const size = Number(b.size);
                        if (Number.isFinite(price) && Number.isFinite(size)) bidNotional += price * size;
                    }
                    for (const a of asks) {
                        const price = Number(a.price);
                        const size = Number(a.size);
                        if (Number.isFinite(price) && Number.isFinite(size)) askNotional += price * size;
                    }
                    totals[spec.key] = bidNotional + askNotional;
                    bandTotals[spec.key] = { bid: bidNotional, ask: askNotional };
                } else {
                    const depth = accumulateDepth(bids, asks, mid, spec.pct / 100);
                    totals[spec.key] = depth.total;
                    bandTotals[spec.key] = { bid: depth.bidNotional, ask: depth.askNotional };
                }
            }
            return { totals, bandTotals };
        }

        async function computeAveragedDepth(pair, samples, intervalMs) {
            const totalsSum = {};
            const bidsSum = {};
            const asksSum = {};
            for (const spec of DEPTH_BANDS) {
                totalsSum[spec.key] = 0;
                bidsSum[spec.key] = 0;
                asksSum[spec.key] = 0;
            }

            let midSum = 0;
            let ok = 0;

            for (let i = 0; i < samples; i++) {
                try {
                    const obUrl = joinUrl(BASE_URL, ORDERBOOK_PATH_TMPL.replace('{market}', encodeURIComponent(pair)));
                    const ob = await fetchJson(obUrl);
                    const bids = Array.isArray(ob.bids) ? ob.bids : [];
                    const asks = Array.isArray(ob.asks) ? ob.asks : [];
                    const mid = computeMid(bids, asks);
                    if (!Number.isFinite(mid)) {
                        // skip this sample
                    } else {
                        ok += 1;
                        midSum += mid;
                        const { totals, bandTotals } = computeBandTotals(bids, asks, mid);
                        for (const spec of DEPTH_BANDS) {
                            const k = spec.key;
                            totalsSum[k] += totals[k];
                            bidsSum[k] += bandTotals[k].bid;
                            asksSum[k] += bandTotals[k].ask;
                        }
                    }
                } catch (_) {
                    // skip this sample
                }
                if (i < samples - 1) await sleep(intervalMs);
            }

            if (!ok) throw new Error('No successful orderbook snapshots');

            const mid = midSum / ok;
            const totals = {};
            const bandTotals = {};
            for (const spec of DEPTH_BANDS) {
                const k = spec.key;
                totals[k] = totalsSum[k] / ok;
                bandTotals[k] = { ask: asksSum[k] / ok, bid: bidsSum[k] / ok };
            }
            return { mid, totals, bandTotals };
        }

        function makeMainRow(pair, mid, totals, volume24h, oiUsd, bandTotals) {
            const tr = document.createElement('tr');
            tr.className = 'main-row market-row';
            tr.dataset.pair = pair;
            tr.dataset.mid = mid;
            tr.dataset.volume24h = volume24h || 0;
            tr.dataset.oiUsd = oiUsd || 0;
            tr.onclick = () => toggleDetails(pair, tr);
            const cells = [];
            cells.push(`<td><span class="pair"><span class="caret"></span><strong>${pair}</strong></span></td>`);
            cells.push(`<td class="right">${fmtUsd(volume24h)}</td>`);
            cells.push(`<td class="right">${fmtUsd(oiUsd)}</td>`);
            cells.push(`<td class="right">${fmtUsdMid(mid)}</td>`);
            for (const spec of DEPTH_BANDS) {
                cells.push(`<td class="right">${fmtUsd(totals[spec.key])}</td>`);
            }
            tr.innerHTML = cells.join('');
            // Attach hover tooltips to depth cells with price range and notional info
            const tds = tr.querySelectorAll('td');
            if (tds && tds.length >= 4 + DEPTH_BANDS.length) {
                for (let i = 0; i < DEPTH_BANDS.length; i++) {
                    const spec = DEPTH_BANDS[i];
                    const cell = tds[4 + i];
                    if (spec.pct !== null) {
                        cell.title = makeDepthTooltip(pair, Number(mid), spec.pct, bandTotals);
                    } else {
                        cell.title = '';
                    }
                }
            }
            return tr;
        }

        function makeTotalsSubRow(pair, totals) {
            const tr = document.createElement('tr');
            tr.className = 'sub-row market-row';
            tr.id = `details-${pair}`;
            const parts = [];
            parts.push('<td></td>'); // ticker
            parts.push('<td></td>'); // volume
            parts.push('<td></td>'); // oi
            parts.push('<td></td>'); // mid
            for (const spec of DEPTH_BANDS) {
                const k = spec.key;
                parts.push(`
                <td>
                    <div class="depth-breakdown">
                        <div class="depth-item">
                            <span class="depth-item-label">asks</span>
                            <span class="depth-item-value ask">${fmtUsd((totals[k] || {}).ask)}</span>
                        </div>
                        <div class="depth-item">
                            <span class="depth-item-label">bids</span>
                            <span class="depth-item-value bid">${fmtUsd((totals[k] || {}).bid)}</span>
                        </div>
                    </div>
                </td>`);
            }
            tr.innerHTML = parts.join('');
            return tr;
        }

        function toggleDetails(pair, mainRow) {
            document.querySelectorAll('tr.sub-row.market-row').forEach(r => {
                if (r.id !== `details-${pair}`) r.style.display = 'none';
            });
            document.querySelectorAll('tr.main-row.market-row').forEach(r => {
                if (r !== mainRow) r.classList.remove('expanded');
            });

            const row = document.getElementById(`details-${pair}`);
            if (row) {
                const newDisplay = row.style.display === 'table-row' ? 'none' : 'table-row';
                row.style.display = newDisplay;
                if (newDisplay === 'table-row') mainRow.classList.add('expanded');
                else mainRow.classList.remove('expanded');
            }
        }

        let cachedData = [];

        function renderTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            data.forEach(item => {
                const mainRow = makeMainRow(item.pair, item.mid, item.totals, item.volume24h, item.oiUsd, item.bandTotals);
                if (item.group) mainRow.dataset.group = item.group;
                tbody.appendChild(mainRow);
                const subRow = makeTotalsSubRow(item.pair, item.bandTotals);
                tbody.appendChild(subRow);
            });
            updateSummary(data);
        }

        function appendRow(item) {
            const tbody = document.getElementById('tableBody');
            const mainRow = makeMainRow(item.pair, item.mid, item.totals, item.volume24h, item.oiUsd, item.bandTotals);
            if (item.group) mainRow.dataset.group = item.group;
            tbody.appendChild(mainRow);
            const subRow = makeTotalsSubRow(item.pair, item.bandTotals);
            tbody.appendChild(subRow);
        }

        function makeGroupHeader(title, subtitle) {
            const tr = document.createElement('tr');
            tr.className = 'group-row';
            tr.innerHTML = `<td colspan="${columnCount()}">${title} <span class="group-sub">${subtitle}</span></td>`;
            return tr;
        }

        function getGroupSubtitle(group) {
            if (group === 'Group 1') return 'BTC-USD and ETH-USD';
            if (group === 'Group 2') return 'Volume rank 3–10';
            if (group === 'Group 3') return 'Volume rank 11–30';
            return 'Volume rank 31+';
        }

        function renderFromCache() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            const order = ['Group 1', 'Group 2', 'Group 3', 'Group 4'];

            const valOf = (it) => {
                switch (sortState.column) {
                    case 'ticker': return it.pair;
                    case 'volume24h': return Number(it.volume24h || 0);
                    case 'oiUsd': return Number(it.oiUsd || 0);
                    case 'mid': return Number(it.mid || 0);
                    default:
                        if (String(sortState.column || '').startsWith('depth-')) {
                            const key = String(sortState.column).slice(6);
                            return Number((it.totals || {})[key] || 0);
                        }
                        return 0;
                }
            };

            for (const g of order) {
                const items = cachedData.filter(x => x.group === g);
                if (!items.length) continue;
                tbody.appendChild(makeGroupHeader(g, getGroupSubtitle(g)));
                if (sortState.column) {
                    items.sort((a, b) => {
                        const av = valOf(a), bv = valOf(b);
                        if (sortState.column === 'ticker') {
                            return sortState.direction === 'asc' ? String(av).localeCompare(String(bv)) : String(bv).localeCompare(String(av));
                        }
                        return sortState.direction === 'asc' ? av - bv : bv - av;
                    });
                }
                for (const it of items) {
                    const mainRow = makeMainRow(it.pair, it.mid, it.totals, it.volume24h, it.oiUsd, it.bandTotals);
                    mainRow.dataset.group = g;
                    tbody.appendChild(mainRow);
                    const subRow = makeTotalsSubRow(it.pair, it.bandTotals);
                    tbody.appendChild(subRow);
                }
            }

            // Rebind expand handlers
            document.querySelectorAll('tr.main-row.market-row').forEach(tr => {
                const pair = tr.dataset.pair;
                tr.onclick = () => toggleDetails(pair, tr);
            });
        }

        function updateSummary(data) {
            const totals = { m: data.length };
            const elM = document.getElementById('sumMarkets');
            if (elM) elM.textContent = `Total markets: ${totals.m}`;
        }

        async function loadData() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            loading.style.display = 'block';
            error.style.display = 'none';
            error.textContent = '';
            cachedData = [];
            const pbInner = document.getElementById('pbInner');
            const pbText = document.getElementById('pbText');
            pbInner.style.width = '0%';
            pbText.textContent = 'Fetching markets...';

            try {
                const marketsUrl = joinUrl(BASE_URL, MARKETS_PATH);
                const marketsJson = await fetchJson(marketsUrl);
                const marketIds = marketsJson && marketsJson.markets ? Object.keys(marketsJson.markets) : [];
                // Filter out inactive pairs (status: FINAL_SETTLEMENT)
                const marketsMap = marketsJson.markets || {};
                const activeIds = marketIds.filter(t => {
                    const m = marketsMap[t] || {};
                    const status = (m.status || '').toUpperCase();
                    const vol = Number(m.volume24H || 0);
                    return status !== 'FINAL_SETTLEMENT' && vol >= 1000;
                });
                // Sort by 24h volume desc
                const sorted = activeIds
                    .map(t => ({ ticker: t, volume: Number((marketsMap[t] || {}).volume24H || 0) }))
                    .sort((a, b) => b.volume - a.volume)
                    .map(o => o.ticker);

                // Assign groups by rank (1-based), with Group 1 overridden for BTC-USD and ETH-USD
                const groupMap = new Map();
                const g1Set = new Set(['BTC-USD', 'ETH-USD']);
                sorted.forEach((t, i) => {
                    if (g1Set.has(t)) {
                        groupMap.set(t, 'Group 1');
                    } else {
                        const rank = i + 1;
                        if (rank >= 3 && rank <= 10) groupMap.set(t, 'Group 2');
                        else if (rank >= 11 && rank <= 30) groupMap.set(t, 'Group 3');
                        else groupMap.set(t, 'Group 4');
                    }
                });

                const selected = sorted; // load all active by volume order
                const total = selected.length;

                let idx = 0;
                const zeroTickers = [];
                const insertedGroups = new Set();
                for (const pair of selected) {
                    // Insert group header when encountering the first ticker of a group
                    const group = groupMap.get(pair) || 'Group 4';
                    if (!insertedGroups.has(group)) {
                        const title = group;
                        let subtitle = '';
                        if (group === 'Group 1') subtitle = 'BTC-USD and ETH-USD';
                        else if (group === 'Group 2') subtitle = 'Volume rank 3–10';
                        else if (group === 'Group 3') subtitle = 'Volume rank 11–30';
                        else subtitle = 'Volume rank 31+';
                        document.getElementById('tableBody').appendChild(makeGroupHeader(title, subtitle));
                        insertedGroups.add(group);
                    }
                    let mid, totals, bandTotals;
                    try {
                        if (SAMPLING.enabled) {
                            const averaged = await computeAveragedDepth(pair, SAMPLING.samples, SAMPLING.intervalMs);
                            mid = averaged.mid;
                            totals = averaged.totals;
                            bandTotals = averaged.bandTotals;
                        } else {
                            const obUrl = joinUrl(BASE_URL, ORDERBOOK_PATH_TMPL.replace('{market}', encodeURIComponent(pair)));
                            const ob = await fetchJson(obUrl);
                            const bids = Array.isArray(ob.bids) ? ob.bids : [];
                            const asks = Array.isArray(ob.asks) ? ob.asks : [];
                            mid = computeMid(bids, asks);
                            const comp = computeBandTotals(bids, asks, mid);
                            totals = comp.totals;
                            bandTotals = comp.bandTotals;
                        }
                    } catch (e) {
                        const tr = document.createElement('tr');
                        tr.className = 'main-row market-row';
                        tr.innerHTML = `<td><strong>${pair}</strong></td><td colspan="${columnCount() - 1}" class="muted">Orderbook error</td>`;
                        tbody.appendChild(tr);
                        continue;
                    }

                    const marketMeta = marketsMap[pair] || {};
                    const oiUsd = Number(marketMeta.openInterest || 0) * Number(marketMeta.oraclePrice || 0);
                    const volume24h = Number(marketMeta.volume24H || 0);
                    const entry = {
                        pair,
                        mid,
                        totals,
                        volume24h,
                        oiUsd,
                        bandTotals,
                        group
                    };
                    cachedData.push(entry);
                    appendRow(entry); // incrementally render row
                    const allZero = Object.values(entry.totals).every(v => Number(v) === 0);
                    if (allZero) zeroTickers.push(pair);
                    idx += 1;
                    pbInner.style.width = `${Math.round((idx/total)*100)}%`;
                    pbText.textContent = `Loading ${idx}/${total} markets...`;
                }
                updateSummary(cachedData);
                if (zeroTickers.length) {
                    await retryZeroTickers(zeroTickers, 3);
                }
            } catch (e) {
                error.textContent = String(e);
                error.style.display = 'block';
            } finally {
                loading.style.display = 'none';
                document.getElementById('pbText').textContent = 'Done';
            }
        }

        async function retryZeroTickers(tickers, attempts) {
            const pbInner = document.getElementById('pbInner');
            const pbText = document.getElementById('pbText');
            for (let a = 1; a <= attempts && tickers.length; a++) {
                pbText.textContent = `Retry pass ${a}/${attempts} for ${tickers.length} tickers...`;
                const stillZero = [];
                let done = 0;
                for (const pair of tickers) {
                    try {
                        let mid, totals, bandTotals;
                        if (SAMPLING.enabled) {
                            const averaged = await computeAveragedDepth(pair, SAMPLING.retrySamples, SAMPLING.intervalMs);
                            mid = averaged.mid;
                            totals = averaged.totals;
                            bandTotals = averaged.bandTotals;
                        } else {
                            const obUrl = joinUrl(BASE_URL, ORDERBOOK_PATH_TMPL.replace('{market}', encodeURIComponent(pair)));
                            const ob = await fetchJson(obUrl);
                            const bids = Array.isArray(ob.bids) ? ob.bids : [];
                            const asks = Array.isArray(ob.asks) ? ob.asks : [];
                            mid = computeMid(bids, asks);
                            const comp = computeBandTotals(bids, asks, mid);
                            totals = comp.totals;
                            bandTotals = comp.bandTotals;
                        }
                        const entry = cachedData.find(e => e.pair === pair);
                        if (entry) {
                            entry.mid = mid;
                            entry.totals = totals;
                            entry.bandTotals = bandTotals;
                            updateRow(pair, entry);
                        }
                        const allZero = Object.values(totals).every(v => Number(v) === 0);
                        if (allZero) stillZero.push(pair);
                    } catch (_) {
                        stillZero.push(pair);
                    }
                    done += 1;
                    pbInner.style.width = `${Math.round((done/tickers.length)*100)}%`;
                }
                tickers = stillZero;
            }
            updateSummary(cachedData);
        }

        function updateRow(pair, entry) {
            const mainRow = document.querySelector(`tr.main-row[data-pair="${pair}"]`);
            const subRow = document.getElementById(`details-${pair}`);
            if (!mainRow || !subRow) return;
            const newMain = makeMainRow(entry.pair, entry.mid, entry.totals, entry.volume24h, entry.oiUsd, entry.bandTotals);
            if (mainRow.dataset.group) newMain.dataset.group = mainRow.dataset.group;
            mainRow.replaceWith(newMain);
            const newSub = makeTotalsSubRow(entry.pair, entry.bandTotals);
            subRow.replaceWith(newSub);
        }

        let sortState = { column: null, direction: 'asc' };

        function sortTable(column) {
            // Update sort state and rebuild from cached data instead of shuffling live nodes

            if (sortState.column === column) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.column = column;
                sortState.direction = 'asc';
            }

            renderFromCache();
            

            document.querySelectorAll('thead th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });
            const activeHeader = document.querySelector(`thead th[data-column="${column}"]`);
            if (activeHeader) {
                activeHeader.classList.add(sortState.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
            }

            // Rebind row click handlers after DOM shuffling (in case listeners were dropped)
            document.querySelectorAll('tr.main-row.market-row').forEach(tr => {
                const pair = tr.dataset.pair;
                tr.onclick = () => toggleDetails(pair, tr);
            });
        }

        buildTableHeader();
        document.querySelectorAll('thead th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.dataset.column;
                sortTable(column);
            });
        });

        document.getElementById('refreshBtn').addEventListener('click', loadData);
        document.getElementById('formatSelect').addEventListener('change', (e) => {
            formatMode = e.target.value;
            if (cachedData.length) {
                // Re-render with new format without refetching
                const open = document.querySelector('tr.sub-row[style*="table-row"]');
                renderTable(cachedData);
                // Keep accordion state collapsed by default after re-render
            }
        });
        renderSamplingInfo();
        loadData();
            </script>
        </body>
        </html>
